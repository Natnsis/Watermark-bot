
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Refinement` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Refinement
 * 
 */
export type RefinementModel = runtime.Types.Result.DefaultSelection<Prisma.$RefinementPayload>

export type AggregateRefinement = {
  _count: RefinementCountAggregateOutputType | null
  _avg: RefinementAvgAggregateOutputType | null
  _sum: RefinementSumAggregateOutputType | null
  _min: RefinementMinAggregateOutputType | null
  _max: RefinementMaxAggregateOutputType | null
}

export type RefinementAvgAggregateOutputType = {
  id: number | null
}

export type RefinementSumAggregateOutputType = {
  id: number | null
}

export type RefinementMinAggregateOutputType = {
  id: number | null
  userId: string | null
  funnyRef: boolean | null
  grammarRef: boolean | null
  professional: boolean | null
}

export type RefinementMaxAggregateOutputType = {
  id: number | null
  userId: string | null
  funnyRef: boolean | null
  grammarRef: boolean | null
  professional: boolean | null
}

export type RefinementCountAggregateOutputType = {
  id: number
  userId: number
  funnyRef: number
  grammarRef: number
  professional: number
  _all: number
}


export type RefinementAvgAggregateInputType = {
  id?: true
}

export type RefinementSumAggregateInputType = {
  id?: true
}

export type RefinementMinAggregateInputType = {
  id?: true
  userId?: true
  funnyRef?: true
  grammarRef?: true
  professional?: true
}

export type RefinementMaxAggregateInputType = {
  id?: true
  userId?: true
  funnyRef?: true
  grammarRef?: true
  professional?: true
}

export type RefinementCountAggregateInputType = {
  id?: true
  userId?: true
  funnyRef?: true
  grammarRef?: true
  professional?: true
  _all?: true
}

export type RefinementAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Refinement to aggregate.
   */
  where?: Prisma.RefinementWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Refinements to fetch.
   */
  orderBy?: Prisma.RefinementOrderByWithRelationInput | Prisma.RefinementOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RefinementWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Refinements from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Refinements.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Refinements
  **/
  _count?: true | RefinementCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RefinementAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RefinementSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RefinementMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RefinementMaxAggregateInputType
}

export type GetRefinementAggregateType<T extends RefinementAggregateArgs> = {
      [P in keyof T & keyof AggregateRefinement]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRefinement[P]>
    : Prisma.GetScalarType<T[P], AggregateRefinement[P]>
}




export type RefinementGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RefinementWhereInput
  orderBy?: Prisma.RefinementOrderByWithAggregationInput | Prisma.RefinementOrderByWithAggregationInput[]
  by: Prisma.RefinementScalarFieldEnum[] | Prisma.RefinementScalarFieldEnum
  having?: Prisma.RefinementScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RefinementCountAggregateInputType | true
  _avg?: RefinementAvgAggregateInputType
  _sum?: RefinementSumAggregateInputType
  _min?: RefinementMinAggregateInputType
  _max?: RefinementMaxAggregateInputType
}

export type RefinementGroupByOutputType = {
  id: number
  userId: string
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
  _count: RefinementCountAggregateOutputType | null
  _avg: RefinementAvgAggregateOutputType | null
  _sum: RefinementSumAggregateOutputType | null
  _min: RefinementMinAggregateOutputType | null
  _max: RefinementMaxAggregateOutputType | null
}

type GetRefinementGroupByPayload<T extends RefinementGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RefinementGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RefinementGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RefinementGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RefinementGroupByOutputType[P]>
      }
    >
  >



export type RefinementWhereInput = {
  AND?: Prisma.RefinementWhereInput | Prisma.RefinementWhereInput[]
  OR?: Prisma.RefinementWhereInput[]
  NOT?: Prisma.RefinementWhereInput | Prisma.RefinementWhereInput[]
  id?: Prisma.IntFilter<"Refinement"> | number
  userId?: Prisma.StringFilter<"Refinement"> | string
  funnyRef?: Prisma.BoolFilter<"Refinement"> | boolean
  grammarRef?: Prisma.BoolFilter<"Refinement"> | boolean
  professional?: Prisma.BoolFilter<"Refinement"> | boolean
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type RefinementOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  funnyRef?: Prisma.SortOrder
  grammarRef?: Prisma.SortOrder
  professional?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
}

export type RefinementWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  userId?: string
  AND?: Prisma.RefinementWhereInput | Prisma.RefinementWhereInput[]
  OR?: Prisma.RefinementWhereInput[]
  NOT?: Prisma.RefinementWhereInput | Prisma.RefinementWhereInput[]
  funnyRef?: Prisma.BoolFilter<"Refinement"> | boolean
  grammarRef?: Prisma.BoolFilter<"Refinement"> | boolean
  professional?: Prisma.BoolFilter<"Refinement"> | boolean
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "userId">

export type RefinementOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  funnyRef?: Prisma.SortOrder
  grammarRef?: Prisma.SortOrder
  professional?: Prisma.SortOrder
  _count?: Prisma.RefinementCountOrderByAggregateInput
  _avg?: Prisma.RefinementAvgOrderByAggregateInput
  _max?: Prisma.RefinementMaxOrderByAggregateInput
  _min?: Prisma.RefinementMinOrderByAggregateInput
  _sum?: Prisma.RefinementSumOrderByAggregateInput
}

export type RefinementScalarWhereWithAggregatesInput = {
  AND?: Prisma.RefinementScalarWhereWithAggregatesInput | Prisma.RefinementScalarWhereWithAggregatesInput[]
  OR?: Prisma.RefinementScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RefinementScalarWhereWithAggregatesInput | Prisma.RefinementScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Refinement"> | number
  userId?: Prisma.StringWithAggregatesFilter<"Refinement"> | string
  funnyRef?: Prisma.BoolWithAggregatesFilter<"Refinement"> | boolean
  grammarRef?: Prisma.BoolWithAggregatesFilter<"Refinement"> | boolean
  professional?: Prisma.BoolWithAggregatesFilter<"Refinement"> | boolean
}

export type RefinementCreateInput = {
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
  user: Prisma.UserCreateNestedOneWithoutRefinementsInput
}

export type RefinementUncheckedCreateInput = {
  id?: number
  userId: string
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
}

export type RefinementUpdateInput = {
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
  user?: Prisma.UserUpdateOneRequiredWithoutRefinementsNestedInput
}

export type RefinementUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type RefinementCreateManyInput = {
  id?: number
  userId: string
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
}

export type RefinementUpdateManyMutationInput = {
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type RefinementUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type RefinementListRelationFilter = {
  every?: Prisma.RefinementWhereInput
  some?: Prisma.RefinementWhereInput
  none?: Prisma.RefinementWhereInput
}

export type RefinementOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RefinementCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  funnyRef?: Prisma.SortOrder
  grammarRef?: Prisma.SortOrder
  professional?: Prisma.SortOrder
}

export type RefinementAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type RefinementMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  funnyRef?: Prisma.SortOrder
  grammarRef?: Prisma.SortOrder
  professional?: Prisma.SortOrder
}

export type RefinementMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  funnyRef?: Prisma.SortOrder
  grammarRef?: Prisma.SortOrder
  professional?: Prisma.SortOrder
}

export type RefinementSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type RefinementCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput> | Prisma.RefinementCreateWithoutUserInput[] | Prisma.RefinementUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RefinementCreateOrConnectWithoutUserInput | Prisma.RefinementCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.RefinementCreateManyUserInputEnvelope
  connect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
}

export type RefinementUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput> | Prisma.RefinementCreateWithoutUserInput[] | Prisma.RefinementUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RefinementCreateOrConnectWithoutUserInput | Prisma.RefinementCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.RefinementCreateManyUserInputEnvelope
  connect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
}

export type RefinementUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput> | Prisma.RefinementCreateWithoutUserInput[] | Prisma.RefinementUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RefinementCreateOrConnectWithoutUserInput | Prisma.RefinementCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.RefinementUpsertWithWhereUniqueWithoutUserInput | Prisma.RefinementUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.RefinementCreateManyUserInputEnvelope
  set?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  disconnect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  delete?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  connect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  update?: Prisma.RefinementUpdateWithWhereUniqueWithoutUserInput | Prisma.RefinementUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.RefinementUpdateManyWithWhereWithoutUserInput | Prisma.RefinementUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.RefinementScalarWhereInput | Prisma.RefinementScalarWhereInput[]
}

export type RefinementUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput> | Prisma.RefinementCreateWithoutUserInput[] | Prisma.RefinementUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RefinementCreateOrConnectWithoutUserInput | Prisma.RefinementCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.RefinementUpsertWithWhereUniqueWithoutUserInput | Prisma.RefinementUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.RefinementCreateManyUserInputEnvelope
  set?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  disconnect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  delete?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  connect?: Prisma.RefinementWhereUniqueInput | Prisma.RefinementWhereUniqueInput[]
  update?: Prisma.RefinementUpdateWithWhereUniqueWithoutUserInput | Prisma.RefinementUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.RefinementUpdateManyWithWhereWithoutUserInput | Prisma.RefinementUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.RefinementScalarWhereInput | Prisma.RefinementScalarWhereInput[]
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type RefinementCreateWithoutUserInput = {
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
}

export type RefinementUncheckedCreateWithoutUserInput = {
  id?: number
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
}

export type RefinementCreateOrConnectWithoutUserInput = {
  where: Prisma.RefinementWhereUniqueInput
  create: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput>
}

export type RefinementCreateManyUserInputEnvelope = {
  data: Prisma.RefinementCreateManyUserInput | Prisma.RefinementCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type RefinementUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.RefinementWhereUniqueInput
  update: Prisma.XOR<Prisma.RefinementUpdateWithoutUserInput, Prisma.RefinementUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.RefinementCreateWithoutUserInput, Prisma.RefinementUncheckedCreateWithoutUserInput>
}

export type RefinementUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.RefinementWhereUniqueInput
  data: Prisma.XOR<Prisma.RefinementUpdateWithoutUserInput, Prisma.RefinementUncheckedUpdateWithoutUserInput>
}

export type RefinementUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.RefinementScalarWhereInput
  data: Prisma.XOR<Prisma.RefinementUpdateManyMutationInput, Prisma.RefinementUncheckedUpdateManyWithoutUserInput>
}

export type RefinementScalarWhereInput = {
  AND?: Prisma.RefinementScalarWhereInput | Prisma.RefinementScalarWhereInput[]
  OR?: Prisma.RefinementScalarWhereInput[]
  NOT?: Prisma.RefinementScalarWhereInput | Prisma.RefinementScalarWhereInput[]
  id?: Prisma.IntFilter<"Refinement"> | number
  userId?: Prisma.StringFilter<"Refinement"> | string
  funnyRef?: Prisma.BoolFilter<"Refinement"> | boolean
  grammarRef?: Prisma.BoolFilter<"Refinement"> | boolean
  professional?: Prisma.BoolFilter<"Refinement"> | boolean
}

export type RefinementCreateManyUserInput = {
  id?: number
  funnyRef: boolean
  grammarRef: boolean
  professional: boolean
}

export type RefinementUpdateWithoutUserInput = {
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type RefinementUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type RefinementUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  funnyRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  grammarRef?: Prisma.BoolFieldUpdateOperationsInput | boolean
  professional?: Prisma.BoolFieldUpdateOperationsInput | boolean
}



export type RefinementSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  funnyRef?: boolean
  grammarRef?: boolean
  professional?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["refinement"]>

export type RefinementSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  funnyRef?: boolean
  grammarRef?: boolean
  professional?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["refinement"]>

export type RefinementSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  funnyRef?: boolean
  grammarRef?: boolean
  professional?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["refinement"]>

export type RefinementSelectScalar = {
  id?: boolean
  userId?: boolean
  funnyRef?: boolean
  grammarRef?: boolean
  professional?: boolean
}

export type RefinementOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "funnyRef" | "grammarRef" | "professional", ExtArgs["result"]["refinement"]>
export type RefinementInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type RefinementIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type RefinementIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $RefinementPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Refinement"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    userId: string
    funnyRef: boolean
    grammarRef: boolean
    professional: boolean
  }, ExtArgs["result"]["refinement"]>
  composites: {}
}

export type RefinementGetPayload<S extends boolean | null | undefined | RefinementDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RefinementPayload, S>

export type RefinementCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RefinementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RefinementCountAggregateInputType | true
  }

export interface RefinementDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refinement'], meta: { name: 'Refinement' } }
  /**
   * Find zero or one Refinement that matches the filter.
   * @param {RefinementFindUniqueArgs} args - Arguments to find a Refinement
   * @example
   * // Get one Refinement
   * const refinement = await prisma.refinement.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RefinementFindUniqueArgs>(args: Prisma.SelectSubset<T, RefinementFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Refinement that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RefinementFindUniqueOrThrowArgs} args - Arguments to find a Refinement
   * @example
   * // Get one Refinement
   * const refinement = await prisma.refinement.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RefinementFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RefinementFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Refinement that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementFindFirstArgs} args - Arguments to find a Refinement
   * @example
   * // Get one Refinement
   * const refinement = await prisma.refinement.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RefinementFindFirstArgs>(args?: Prisma.SelectSubset<T, RefinementFindFirstArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Refinement that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementFindFirstOrThrowArgs} args - Arguments to find a Refinement
   * @example
   * // Get one Refinement
   * const refinement = await prisma.refinement.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RefinementFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RefinementFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Refinements that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Refinements
   * const refinements = await prisma.refinement.findMany()
   * 
   * // Get first 10 Refinements
   * const refinements = await prisma.refinement.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const refinementWithIdOnly = await prisma.refinement.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RefinementFindManyArgs>(args?: Prisma.SelectSubset<T, RefinementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Refinement.
   * @param {RefinementCreateArgs} args - Arguments to create a Refinement.
   * @example
   * // Create one Refinement
   * const Refinement = await prisma.refinement.create({
   *   data: {
   *     // ... data to create a Refinement
   *   }
   * })
   * 
   */
  create<T extends RefinementCreateArgs>(args: Prisma.SelectSubset<T, RefinementCreateArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Refinements.
   * @param {RefinementCreateManyArgs} args - Arguments to create many Refinements.
   * @example
   * // Create many Refinements
   * const refinement = await prisma.refinement.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RefinementCreateManyArgs>(args?: Prisma.SelectSubset<T, RefinementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Refinements and returns the data saved in the database.
   * @param {RefinementCreateManyAndReturnArgs} args - Arguments to create many Refinements.
   * @example
   * // Create many Refinements
   * const refinement = await prisma.refinement.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Refinements and only return the `id`
   * const refinementWithIdOnly = await prisma.refinement.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RefinementCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RefinementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Refinement.
   * @param {RefinementDeleteArgs} args - Arguments to delete one Refinement.
   * @example
   * // Delete one Refinement
   * const Refinement = await prisma.refinement.delete({
   *   where: {
   *     // ... filter to delete one Refinement
   *   }
   * })
   * 
   */
  delete<T extends RefinementDeleteArgs>(args: Prisma.SelectSubset<T, RefinementDeleteArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Refinement.
   * @param {RefinementUpdateArgs} args - Arguments to update one Refinement.
   * @example
   * // Update one Refinement
   * const refinement = await prisma.refinement.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RefinementUpdateArgs>(args: Prisma.SelectSubset<T, RefinementUpdateArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Refinements.
   * @param {RefinementDeleteManyArgs} args - Arguments to filter Refinements to delete.
   * @example
   * // Delete a few Refinements
   * const { count } = await prisma.refinement.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RefinementDeleteManyArgs>(args?: Prisma.SelectSubset<T, RefinementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Refinements.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Refinements
   * const refinement = await prisma.refinement.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RefinementUpdateManyArgs>(args: Prisma.SelectSubset<T, RefinementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Refinements and returns the data updated in the database.
   * @param {RefinementUpdateManyAndReturnArgs} args - Arguments to update many Refinements.
   * @example
   * // Update many Refinements
   * const refinement = await prisma.refinement.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Refinements and only return the `id`
   * const refinementWithIdOnly = await prisma.refinement.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RefinementUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RefinementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Refinement.
   * @param {RefinementUpsertArgs} args - Arguments to update or create a Refinement.
   * @example
   * // Update or create a Refinement
   * const refinement = await prisma.refinement.upsert({
   *   create: {
   *     // ... data to create a Refinement
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Refinement we want to update
   *   }
   * })
   */
  upsert<T extends RefinementUpsertArgs>(args: Prisma.SelectSubset<T, RefinementUpsertArgs<ExtArgs>>): Prisma.Prisma__RefinementClient<runtime.Types.Result.GetResult<Prisma.$RefinementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Refinements.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementCountArgs} args - Arguments to filter Refinements to count.
   * @example
   * // Count the number of Refinements
   * const count = await prisma.refinement.count({
   *   where: {
   *     // ... the filter for the Refinements we want to count
   *   }
   * })
  **/
  count<T extends RefinementCountArgs>(
    args?: Prisma.Subset<T, RefinementCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RefinementCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Refinement.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RefinementAggregateArgs>(args: Prisma.Subset<T, RefinementAggregateArgs>): Prisma.PrismaPromise<GetRefinementAggregateType<T>>

  /**
   * Group by Refinement.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RefinementGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RefinementGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RefinementGroupByArgs['orderBy'] }
      : { orderBy?: RefinementGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RefinementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefinementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Refinement model
 */
readonly fields: RefinementFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Refinement.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RefinementClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Refinement model
 */
export interface RefinementFieldRefs {
  readonly id: Prisma.FieldRef<"Refinement", 'Int'>
  readonly userId: Prisma.FieldRef<"Refinement", 'String'>
  readonly funnyRef: Prisma.FieldRef<"Refinement", 'Boolean'>
  readonly grammarRef: Prisma.FieldRef<"Refinement", 'Boolean'>
  readonly professional: Prisma.FieldRef<"Refinement", 'Boolean'>
}
    

// Custom InputTypes
/**
 * Refinement findUnique
 */
export type RefinementFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter, which Refinement to fetch.
   */
  where: Prisma.RefinementWhereUniqueInput
}

/**
 * Refinement findUniqueOrThrow
 */
export type RefinementFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter, which Refinement to fetch.
   */
  where: Prisma.RefinementWhereUniqueInput
}

/**
 * Refinement findFirst
 */
export type RefinementFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter, which Refinement to fetch.
   */
  where?: Prisma.RefinementWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Refinements to fetch.
   */
  orderBy?: Prisma.RefinementOrderByWithRelationInput | Prisma.RefinementOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Refinements.
   */
  cursor?: Prisma.RefinementWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Refinements from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Refinements.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Refinements.
   */
  distinct?: Prisma.RefinementScalarFieldEnum | Prisma.RefinementScalarFieldEnum[]
}

/**
 * Refinement findFirstOrThrow
 */
export type RefinementFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter, which Refinement to fetch.
   */
  where?: Prisma.RefinementWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Refinements to fetch.
   */
  orderBy?: Prisma.RefinementOrderByWithRelationInput | Prisma.RefinementOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Refinements.
   */
  cursor?: Prisma.RefinementWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Refinements from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Refinements.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Refinements.
   */
  distinct?: Prisma.RefinementScalarFieldEnum | Prisma.RefinementScalarFieldEnum[]
}

/**
 * Refinement findMany
 */
export type RefinementFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter, which Refinements to fetch.
   */
  where?: Prisma.RefinementWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Refinements to fetch.
   */
  orderBy?: Prisma.RefinementOrderByWithRelationInput | Prisma.RefinementOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Refinements.
   */
  cursor?: Prisma.RefinementWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Refinements from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Refinements.
   */
  skip?: number
  distinct?: Prisma.RefinementScalarFieldEnum | Prisma.RefinementScalarFieldEnum[]
}

/**
 * Refinement create
 */
export type RefinementCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * The data needed to create a Refinement.
   */
  data: Prisma.XOR<Prisma.RefinementCreateInput, Prisma.RefinementUncheckedCreateInput>
}

/**
 * Refinement createMany
 */
export type RefinementCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Refinements.
   */
  data: Prisma.RefinementCreateManyInput | Prisma.RefinementCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Refinement createManyAndReturn
 */
export type RefinementCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * The data used to create many Refinements.
   */
  data: Prisma.RefinementCreateManyInput | Prisma.RefinementCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Refinement update
 */
export type RefinementUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * The data needed to update a Refinement.
   */
  data: Prisma.XOR<Prisma.RefinementUpdateInput, Prisma.RefinementUncheckedUpdateInput>
  /**
   * Choose, which Refinement to update.
   */
  where: Prisma.RefinementWhereUniqueInput
}

/**
 * Refinement updateMany
 */
export type RefinementUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Refinements.
   */
  data: Prisma.XOR<Prisma.RefinementUpdateManyMutationInput, Prisma.RefinementUncheckedUpdateManyInput>
  /**
   * Filter which Refinements to update
   */
  where?: Prisma.RefinementWhereInput
  /**
   * Limit how many Refinements to update.
   */
  limit?: number
}

/**
 * Refinement updateManyAndReturn
 */
export type RefinementUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * The data used to update Refinements.
   */
  data: Prisma.XOR<Prisma.RefinementUpdateManyMutationInput, Prisma.RefinementUncheckedUpdateManyInput>
  /**
   * Filter which Refinements to update
   */
  where?: Prisma.RefinementWhereInput
  /**
   * Limit how many Refinements to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Refinement upsert
 */
export type RefinementUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * The filter to search for the Refinement to update in case it exists.
   */
  where: Prisma.RefinementWhereUniqueInput
  /**
   * In case the Refinement found by the `where` argument doesn't exist, create a new Refinement with this data.
   */
  create: Prisma.XOR<Prisma.RefinementCreateInput, Prisma.RefinementUncheckedCreateInput>
  /**
   * In case the Refinement was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RefinementUpdateInput, Prisma.RefinementUncheckedUpdateInput>
}

/**
 * Refinement delete
 */
export type RefinementDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
  /**
   * Filter which Refinement to delete.
   */
  where: Prisma.RefinementWhereUniqueInput
}

/**
 * Refinement deleteMany
 */
export type RefinementDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Refinements to delete
   */
  where?: Prisma.RefinementWhereInput
  /**
   * Limit how many Refinements to delete.
   */
  limit?: number
}

/**
 * Refinement without action
 */
export type RefinementDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Refinement
   */
  select?: Prisma.RefinementSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Refinement
   */
  omit?: Prisma.RefinementOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefinementInclude<ExtArgs> | null
}
